#include <iostream>
using namespace std;

/*
언뜻 간단해보이지만, 여기에는 작은 함정이 있다.
위의 문제의 시간 제한은 약 0.25초로 매우 짧은데, 이러한 문제의 특성상 재귀함수인 피보나치 함수를 n의 조건인 40회까지 돌려보면 가뿐하게
0.25초가 넘어간다. 따라서 이 로직은 피보나치 함수의 호출에 상관관계를 생각해보아야 한다.

상관관계를 생각해보면 의외로 간단하게 나타난다.
1을 호출 할 때마다 return이 1이다.
피보나치 수열을 보면 n=0부터 시작했을 때 0, 1, 1, 2, 3, 5, 8... 즉 피보나시 수열 값만큼, 1이 호출된다.
다음은 0인데, 0을 호출할 때마다 return이 0이기에 수치로 알 수가 없다.
따라서 피보나치의 함수를 파악해보면

피보나치(0)이면 0이 1번 호출된다. = 1
피보나치(1)이면 0이 0번 호출된다. = 0
피보나치(2)이면 0과 1이 1번씩 호출된다. = 1
피보나치(3)이면 1과 2이 호출되고, 2가 0과 1이 1번씩 호출된다. = 0 + 1
피보나치(4)이면 2와 3이 호출되고, 2가 0과 1이 1번씩 호출되고, 3이 1과 2를 호출하고... = 1 + (0 + 1)
...

n = 0일 때는 1이고, n >=1 일때는 피보나치 수열을 준수하는 것을 볼 수 있다.

따라서 0을 호출하는 개수를 배열화하여, 이를 answer로 두면
int *answer = { 1 , 0 , 1, 1, 2, 3, 5, 8, 13....}

0을 호출하는 개수는 answer[n]
1을 호출하는 개수는 answer[n+1]일 것이다.
*/

int main() {
	int answer[42] = { 1, 0 };

	for (int i = 2; i <= 41; i++) answer[i] = answer[i - 1] + answer[i - 2];

	int n, k;

	cin >> n;
	
	for (int i = 0; i < n; i++) {
		cin >> k;
		cout << answer[k] << " " << answer[k + 1] << endl;
	}
 
	return 0;
}
